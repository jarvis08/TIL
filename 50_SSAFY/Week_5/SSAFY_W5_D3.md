# SSAFY Week5 Day3

---

## APS, Algorithm Problem Solving 기본

- 백경원 강사님

  과제 제출 beeback@hanmail.net 당일 자정까지

  - Talk > Solving Club > Solving Club > 2기서울1반 > Problem Box > 1문제

  - Learn > Course > Programming Intermediate > 회차 별 4문제

    4문제의 경우 메일로 제출

    메일 제목 : 2기서울1반1월17일조동빈

    파일 제목 : 서울1반1월17일조동빈.zip

- Problem Solving
  
  - Type
  - 제어
    - 순차
    - 선택
  - 반복
  
- ADT, Abstract Data Type

  - 자료

  - 연산

    자료구조 별 논리적 구조를 유지한 채 데이터를 다룸

    - 삽입

    - 삭제

    - **순회**, Traversal

      주어진 자료 구조의 모든 element를 빠짐 없이 조회할 수 있는 방법

- 자료 구조

  - 선형

    element와 element의 관계가 1:1

    자기 자신에서 이어질 수 있는 경우의 수 = 1개

    2차원일 경우, 같은 차원 당 경우의 수 = 1개

    물리적 구조 == 논리적 구조

    - 배열, Array

    - 리스트, List

      탐색기와 같은 개념으로, 비어있는 공간이 존재 하지 않아 삭제 시 리스트 크기 축소

      삽입/삭제가 빈번하게 발생하는 자료에 적합

    - 스택, Stack

    - 큐, Queue

    - 데크, Deck

  - 비선형

    element와 element의 관계가 1:N

    - **트리, Tree**

      - 트리의 표현
        - 1차 배열
        - 리스트
        - 스태틱 링크드 리스트
      - 트리의 순회
        - Pre-Order
        - In-Order
        - Post-Order
        - DFS, BFS를 사용할 수 있지만 닭 잡는데 소 잡는 칼을 쓰는격
      - 트리의 종류
        - 이진 트리
        - 이진 탐색 트리
        - AVL
        - B
        - 트라이
        - 허프만 트리
        - 아호코라식 트리
        - 세그먼트 트리

    - **그래프, Graph**

      Tree 또한 방향이 없는, 무방향의 Graph

      cycle이 가능하며, 방향성이 존재할 수 있다.

      - 그래프의 표현

        - 인접 행렬

        - 인접 리스트

          메모리 소요가 크며, (스태틱) 링크드 리스트를 사용

      - 그래프의 순회

        - **DFS**

          깊이 우선 탐색

          막다른 길이면 되돌아옴

          Stack을 사용

          재귀형식의 경우 DFS 형식으로 호출

          Back Tracking이라고도 불림

        - **BFS**

          Queue를 사용하며, 가까운 것부터 탐색

      - 그래프의 종류

        - MST, Minimum Static Tree

        - 최단 경로

          경로 별 cost 계산

          - 다익스트라 알고리즘
          - TSP, Traveling Salesman Problem
          - 플로이드

        - AoV

        - AoE

        - 네트웍

        - 기하

---

- 알고리즘, Algorithm

  - 정렬

  - 검색

    정렬 상태에 따라 검색 속도가 판이

    - **해쉬, Hash**

    - **완전 검색, Exhaustive Search**

      **Brute-force** 혹은 **Generate-and-Test**라고도 불림

      모든 경우의 수를 테스트한 후 최종 해법 도출

      수행 속도가 느리지만, 해답 탐색 확률이 높다.

      - Coding Test의 경우 완전 검색으로의 접근 후,

        성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인

    - 조합론

      모든 case를 생성하는 방법론

      - 순열

        대표 문제 = TSP

        시간복잡도 O(n!)

        n!의 시간 복잡도를 가지는 완전 검색

      - 조합

      - 부분 집합

        대표 문제 = 배낭 문제

        O(2**n)

        지수승의 시간 복잡도를 가지는 완전 검색(NP 클래스 문제)

        - O(n**k) 시간복잡도를 가지는 완전 검색(P클래스 문제)

        n이 커지면 늙어 죽을때까지 결과 못보기 때문에 다른 방법을 시도(Tree 구조를 활용)
  
      - 근사 알고리즘
        - 인공지능

- Algorithm 설계 기법

  - Greedy

    탐욕 알고리즘 설계 기법

    검증이 필수적이며, 쉽게 사용할 수 없다.

  - 분할 정복

    중요하며, 제어문을 사용할 때 부분적으로 사용

  - **Back Tracking**

    - 상태 공간 트리 문제를 DFS로 해결 할 때, Stack 혹은 재귀를 이용하여 구현

    - 혹은 BFS를 사용하여 우선 순위에 따라 Queue를 이용하여 해결

  - DP, Dynamic Programming

    - 재귀적 DP

      때에 따라서는 재귀적 DP의 속도가 빠른 경우도 존재

      Back Tracking이 기본

    - 반복적 DP

---

- Algorithm : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

  - 슈더코드

    Team마다 다르며, Google에서 만든 대표 문헌이 존재

  - 순서도

    명령어를 기준으로 작성하며, 규모가 커질 수록 abstract한 단위로 표현

  - 좋은 알고리즘

    1. **정확성**

    2. **작업량**

       논리적/물리적인 적은 연산

       - 검정 서버

         10초 제한, 10초안에 output이 나오는가

         검정 환경에 따라 시간 차이가 존재

       - 시간 복잡도

         명령어의 수에 따라 작업량을 계산

         i.g., Big O 표기법

    3. 메모리 사용량

    4. 단순성

       Maintenance 및 Team 단위의 작업에 중요

    5. 최적성

- Big O 표기법

  시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시하며, 계수(Coefficient) 생략

  i.g., `O(3n+2) = O(n)`

  `O(2n^2 + 10n + 100) = O(2n^2)`

  - 시간 복잡도 연산 수 오름차순
    1. `O(1)`
    2. `O(logn)`
    3. `O(n)`
    4. `O(nlogn)`
    5. `O(n^2)`
    6. `O(2^n)`
    7. `O(n!)`

- Array

  **일정한 자료형의 변수들**을 하나의 이름으로 열거하여 사용하는 자료구조

- Baby-gin 문제

  6장의 카드가 `run`+`triplet`으로 구성된 경우(추출 순서 무관)

  i.g., 667767, 054060

  - 0~9 사이의 숫자 카드에서 임의의 카드 6장 추출
    - `run` : 3장의 카드가 연속적인 번호
    - `triplet` : 3장의 카드가 동일한 번호

  - 완전 검색을 이용한 Baby-gin

    1. 모든 숫자 나열을 모두 조사(중복 포함)
  2. 전/후반부 3개 숫자씩 나눈 후 `run`, `triplet` 여부를 테스트
  
- Greedy적 접근법
  
    `run` 혹은 `triplet` 중 한 가지를 고른 후,

    찾아지면 나머지 숫자에 대해 `triplet` 혹은 `run`인지 판단

- 순열, Permutation

  서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

  `nPr = n * (n-1) * ... * (n-r+1)`

  `nPn = n! = n Factorial = n * (n-1) * ... * 2 * 1`
  
- 탐욕, Greedy

  탐욕 알고리즘 설계 기법

  - 최적해를 구하는 데에 사용되는 근시안적인 방법

  - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라 생각되는 것을 선택해 나아가는 방식

  - Local Optimization != Global Optimization

  - 따라서 머릿속에 떠오른 내용은 검증 방법이 필요

  - 동작 과정

    1. 해 선택

       현재 상태에서 부분 문제의 최적해를 구한 후,

       이를 부분해 집합(Solution Set)에 추가

    2. 실행 가능성 검사

       새로운 부분해 집합이 실행 가능한지 확인

       문제의 제약 조건을 위반하지 않는지 검사

    3. 해 검사

       새로운 부분해 집합이 문제의 해가 되는지 확인

       아직 전체 문제의 해가 완성되지 않았다면, 1.의 해 선택부터 다시 시작

  - Greedy의 위험성 예시

    - 거스름돈이 80원일 때 동전 개수 최소화, 동전의 단위 시스템은 {50원, 40원, 10원}

      - Greedy : 4개 (50원, 10원 * 3)
      - 최적해 : 2개 (40원 * 2)

    - Baby-gin

      [1, 1, 1, 2, 3, 4]가 뽑혔다고 했을 때,

      `triplet` 탐색 이후 `run`을 찾으면 baby-gin이지만

      역순으로 탐색하면 baby-gin이 아니다.

---

## 정렬

- 정렬 : 2개 이상의 자료를 특정 기준에 의해 Ascending, 혹은 Descending으로 재배열 하는 것
  - `O(n^2)` : 버블 / 삽입 / 선택 정렬
  - `O(nlongn)` : 퀵 / 병합 / 힙 정렬
  - `O(n)` : 카운팅 정렬(특수한 경우에만 사용 가능)

- 버블 정렬, Bubble Sort

  - 시간 복잡도 = `O(n^2)`

  - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬

  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동

  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨

  ```python
  a = [7, 55, 12 , 44, 49]
  def BubbleSort(a):
      # 4부터 0까지, 비교할 마지막 원소의 index를 의미
      for i in range(len(a)-1, 0, -1):
          # 0부터 i까지, 인접 원소인 [j], [j+1]을 마지막 원소인 [i]까지 비교
          for j in range(0, i):
              if a[j] > a[j+1]:
                  a[j], a[j+1] = a[j+1], a[j]
  # i 당 5, 4, 3, 2, 1회씩 j를 반복
  # n(n+1)/2 = (n^2 + n)/2 => O(n^2)
  ```

- 카운팅 정렬, Counting Sort

  - 평균 수행시간 = 최악 수행시간 = `O(N+k)`

    k : 정수의 최대값

  - 비교환 방식

    같은 값의 인덱스 순서가 변하지 않음

    i.g., [2, 1, 2] -> [1, 2, 2] 일 때 [2]끼리의 순서가 원본과 같음

  - 전제 조건

    1. 공간 할당을 위해 집합 내 가장 큰 값과 최소값을 알 수 있어야하며, 연속된 숫자

       i.g., 0~10 사이의 정수라면 10이라는 값을 알 수 잇다.

    2. type(input) == int 혹은 정수로 표현할 수 있는 자료

       0~1 사이의 확률값 중 소수점 둘째 자리 까지의 숫자 범위는 [0.01, 0.02, ... 0.99]의 값들로 , 100개의 유한한 숫자

  - 과정

    1. Data_list, Count_list, Sorted_list 준비

    2. Count_list의 크기는 중복값이 없는 Data_list의 data 개수이며,

       작은 숫자부터 Count_list에 순서대로 배정됨

    3. Count_list에 data 별 개수를 값으로 넣음

    4. Count_list 요소 별로 자신 이전의 누적 개수를 더해줌

    5. Data_list의 끝에서 부터 시작하여,

       Sorted_list[Count_list[data]]에 해당하는 곳에 data를 삽입

    6. Count_list[data]의 값을 -1