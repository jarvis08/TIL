# Cookie & Session & Cache

참고 자료: [_Jbee](https://asfirstalways.tistory.com/68), [는세](https://ryusae.tistory.com/7)

---

HTTP 의 특성을 파악한다면, 쿠키와 세션을 사용할 수 밖에 없는 이유를 알 수 있습니다.

### HTTP 의 특징 및 쿠키/세션의 사용 이유

과거에는 인터넷의 속도가 느렸으며, 심지어 연결 조차 쉽지 않았습니다. 따라서 서버의 부하를 줄이기 위해, 클라이언트와 서버를 원활하게 위해 인터넷 연결은 Stateless하고, Connectionless 했습니다.

1. **Stateless 프로토콜**

   클라이언트의 상태 정보를 가지지 않는 서버 처리 방식이다.  클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도, 두번째 통신에서 이전 데이터를 유지하지 않는다.

2. **Connectionless 프로토콜**

   클라이언트가 서버에 요청(Request)을 했을 때,그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식이다.

HTTP 1.1 버전에는 연결을 유지하고, 재활용 하는 기능(keep-alive 값으로 변경 가능)이 Default 로 추가되었습니다.

HTML의 요청과 응답은 일시적입니다. 클라이언트가 1회 요청 시, 서버는 하나의 HTML 페이지를 응답하여 반환합니다. HTTP Protocol은 이처럼 Stateless합니다.

그런데, 실제로는 데이터 유지가 필요한 경우가 많습니다. 정보가 유지되지 않으면, 매 페이지 마다 로그인을 다시 해야 하거나, 상품을 선택했는데 구매 페이지에서 선택한 상품의 정보가 없거나 하는 등의 일이 발생할 수 있습니다.

회원 기능은 지속적인 피드백이 가능해야 합니다. **지속적으로 회원 정보(상태, State** <--> Stateless**)를 보유하며, 회원의 권한을 가져야 합니다**. 따라서, **Stateful** 한 상태를 유지하기 위해 **쿠키**와 **세션**을 사용합니다.

<br>

<br>

## 쿠키, Cookie

쿠키는 헨젤과 그레텔의 과자 부스러기에서 영감을 얻은 단어로, 사용자의 **흔적**에 대한 표현입니다. 서버가 사용자의 브라우저에 저장시키는 데이터이며, 유저의 행동 패턴을 주로 저장하는 작은 사이즈의 텍스트 파일이자 정보 패킷의 일종입니다. HTTP의 헤더에는 텍스트 데이터에는 `파일명`, `값 만료기간`, `경로 정보`가 있고 `key`와 `value`로 구성되어 있습니다.

회원 기능을 구현하는 방법 중 하나는 **Cookie**를 활용하는 것입니다. 그런데, 사용자의 컴퓨터를 사용하거나 접근한다면 누구나 쿠키에 입력된 값을 쉽게 확인할 수 있기 때문에 **보안**이 취약합니다. 따라서 서버는 쿠키에 중요한 사용자 정보를 저장해서는 안되며, 웹 페이지 방문 횟수, 배너 클릭 여부 등에 대한 사소한 정보를 저장합니다. 쿠키 정보는 오직 그 쿠키를 작성한 웹 서버만이 Access 할 수 있으며, 사용 기한 만료시 자동 삭제됩니다.

<br>

### 쿠키의 종류

- **세션 쿠키**
- **영구 쿠키**

쿠키에 만료일이 포함되지 않은 경우, 메모리에 저장되며 디스크에는 기록되지 않습니다. 이를 **세션 쿠키**라고 하며, 브라우저를 종료하는 순간 쿠키는 삭제됩니다.

쿠키 정보에 만료일이 포함되어 있는 경우, 브라우저를 종료해도 사용자의 디스크에 쿠키 내용을 저장하며, 만료 시기가 됐을 때 삭제됩니다. 이러한 쿠키는 **영구 쿠키**라고 합니다.

<br>

### 쿠키를 사용하여 통신하는 방법

1.  최초 통신에서는 쿠키값이 없으므로, 서버로 일반적인 Request을 한다.

2. 서버에서 클라이언트가 보낸 Request Header에 쿠키가 없음을 판별하며,

   통신 상태(UserID, Password, 조작상태, 방문횟수 등)를 저장한 쿠키를 Response한다.

3. 클라이언트의 브라우저가 쿠키를 저장한다.

4. 이후, 클라이언트의 브라우저는 HTTP Header에 쿠키 데이터를 포함하여 서버에 Request 한다.

<br>

### 쿠키 제약 조건

- 클라이언트는 총 300개의 쿠키를 저장할 수 있다.

- 하나의 도메인 당 20개의 쿠키를 가질 수 있으며,

  20개가 넘으면 가장 적게 사용되는 것부터 삭제한다.

- 하나의 쿠키는 4 KB(4096 Byte) 크기의 데이터를 저장할 수 있다.

<br>

### **쿠키의 사용 예시**

- 자동 로그인 유지
- 위시 리스트 저장
- 팝업 보지 않기
- 사용자 이전 스크롤링
- 뷰 설정 값

<br>

<br>

## 세션, Session

일정 시간 동안 같은 사용자(클라이언트)로 부터 들어오는 일련의 Request를 하나의 상태로 보며, 그 상태를 일정하게 유지시키는 기술입니다. 방문자가 서버에 접속해 있는 상태를 하나의 단위인 **세션**으로 관리합니다. 세션은 클라이언트 마다의 고유한 페이지를 열어두는 역할을 합니다. 사용자 로컬이 아닌 서버에 직접 저장되므로, 세션 내의 데이터를 탈취하는 것은 쿠키에 비해 훨씬 어렵습니다.

세션은 클라이언트가 브라우저를 종료할 때까지 유지 됩니다.

<br>

### **세션 통신 방법**

1. 클라이언트가 서버에 접속 시, **세션 ID를 발급**한다.
2. 서버에서는 클라이언트로 발급해준 **세션 ID를 쿠키**를 이용해서 저장
3. 클라이언트는 다시 페이지에 접속할 때, 쿠키에 저장된 **세션 ID를 포함시켜서 서버에 Request **
4. 서버는 Request Header에 **쿠키 정보(세션 ID)로 클라이언트임을 판별**

세션 ID를 주고 받을 때, 쿠키를 사용하는 경우가 많다.

<br>

### 쿠키와 세션의 차이

세션과 쿠키는 정보 저장의 위치가 다릅니다. **세션**은 각 클라이언트에 고유 ID를 부여하여 **서버**에 저장되는 방식하는 방식이며, **쿠키**는 서버에서 보낸 정보를 **클라이언트의 PC**에 저장합니다.

|                   | Cookie         | Session                                    |
| ----------------- | -------------- | ------------------------------------------ |
| 저장 위치         | Client Browser | Server                                     |
| 보안              | 취약           | 비교적 좋음                                |
| Data's Life Cycle | 만료 기간 지정 | 브라우저 종료 시 삭제(만료 기간 지정 가능) |
| 속도              | 빠름           | 비교적 느림                                |

속도에 있어서, 세션은 서버에 위치하기 때문에 쿠키보다 느립니다.

<br>

### 세션ID 보안

세션 해킹의 경우, 홈페이지 관리자의 세션 아이디를 탈취하며, 쿠키의 값을 관리자의 세션 아이디로 변경합니다. 그렇게 얻은 관리자의 권한으로 나쁜 행위를 합니다.

세션 해킹 예방 방법은 IP를 활용하여 추가적인 인증을 하는 것입니다. 처음 세션에 로그인 했을 때의 IP를 저장한 후, 페이지 이동 시 마다 현재 IP와 세션의 IP/브라우저 정보(UserAgent) 정보가 같은지 검사하여 사용자를 지속적으로 확인합니다.

<br>

<br>

## 캐시, Cache

Cache의 일반적인 번역은 '은닉처'입니다. 이는 임시적으로 무언가를 저장하기 위한 공간입니다. 컴퓨터에서의 캐시는 Web 뿐만 아니라, PC에도 존재합니다. 우선 웹이 아닌, 우리의 개인 PC 상의 캐시에 대해 먼저 알아보겠습니다.

<br>

### 디스크 캐시, 버퍼

PC에서의 Cache는 CPU에 존재합니다. Cache의 크기는 정말 작기 때문에 정말 중요하고 필요한 정보만을 저장합니다. CPU와 저장 공간의 거리를 비유하자면 다음과 같습니다.

- Cache: 나와 냉장고의 거리
- Main Memory: 나와 달의 거리
- Auxiliary memory: 나와 태양의 거리

이렇듯 캐시는 가장 빠른 속도로 데이터를 읽어올 수 있는 저장 공간입니다.

디스크 캐시는 **읽기 캐시**와 **쓰기 캐시**로 나뉩니다. 읽기 캐시는 읽어들인 내용을 캐시에 저장한 후, 다음 읽기가 필요할 때 빠르게 접근하여 읽습니다. 쓰기 캐시는 또 다시 수정할 일이 있는 파일을 캐시에 임시로 저장한 후, 다시 써야 할 때 빠르게 꺼내와 다시 쓸 수 있습니다. 디스크는 속도가 느리므로, 캐시를 이용한다면 훨씬 빠르게 작업을 수행할 수 있습니다.

어플리케이션들은 같은 작업을 여러번 수행하는 경우가 많으며, 캐시는 작업 속도를 크게 향상시켜줄 수 있습니다.

1. **캐시 히트(Cache Hit)**

   CPU가 참조하려는 메모리가 캐시에 존재하고 있는 경우

2. **캐시 미스(Cache Miss)**

   캐시 히트와 반대로, 메모리에 캐시가 존재하지 않는 경우

<br>

### 웹의 캐시

만약 해외 서버에 데이터를 요청할 때, 그 cost는 굉장히 큽니다. 웹의 캐시는, CPU의 캐시처럼 빠르게 데이터로 접근할 수 있는 리소스 파일들의 임시 저장소와 같습니다. 같은 웹 페이지에 접속할 때 사용자의 PC, 네트워크의 중개소에서 데이터를 로드하므로 서버를 거치지 않아도 됩니다. 그리고 캐시를 이용하는 행위를 **캐싱**이라고 합니다.

이전에 사용되었던 데이터는 다시 사용될 가능성이 높기 때문에, 그러한 데이터들(이미지, 비디오 오디오, CSS/JS 등)을 빠르게 접근할 수 있는 저장소에 저장하여 페이지 로딩 속도를 개선합니다.

웹에서 사용되는 캐시에는 세 가지가 있습니다.

1. 브라우저 캐시, Browser Cache

   클라이언트 어플리케이션(Web Browser)이 내부적으로 보유하는 캐시

2. 프록시 캐시, Proxy Cache

   클라이언트와 서버 사이의, 네트워크 관리자에 의해 네트워크 상에 설치되는 캐시

   - latency 감소
   - 트래픽 감소

3. 게이트웨이 캐시, Gateway Cache

   서버에 존재하는 캐시이며, 클라이언트의 요청에 대한 효율적인 분배를 통해 응답 성능을 향상시킴

웹 페이지 접속 시 페이지 로딩 속도를 향상시켜주는 역할을 합니다. 하지만 캐시로 인해 웹 페이지의 업데이트가 제한되는 경우가 있습니다. 캐시에 저장된 내용은 캐시에서 데이터를 꺼내와서 로드하기 때문에, 업데이트 된 서버의 내용이 적용되지 않을 수 있습니다. 이를 위해 캐시의 만료 기한을 설정하거나, 직접 캐시의 내용을 지워주어야 합니다.

<br>

<br>

## Mobile에서 서로 다른 브라우저, 동일한 광고가 뜨는 이유

모바일에서는 **광고ID(ADID, IDFA)**라는 것이 존재합니다. 이는 전 세계적으로 동일하며, 광고할 아이템을 브라우저에 저장되는 쿠키에서 찾는 것이 아니라, 광고ID를 통해 탐색합니다.

PC에서는 브라우저에 따라 쿠키 데이터가 다르므로 브라우저 별로 보게되는 광고가 달라집니다. 하지만, 모바일의 브라우저들(Chrome, Safari 등)을 변경하더라도, 같은 제품의 광고를 보게 됩니다.



