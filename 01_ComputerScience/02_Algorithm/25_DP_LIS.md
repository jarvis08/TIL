# LIS, Logest increasing Subsequence

참고 자료: [자손9319](https://jason9319.tistory.com/113)

최장 증가 부분 수열은 다음과 같은 문제를 Dynamic Programming을 사용하여 계산합니다.

- 어느 배열에 랜덤하게 숫자들이 존재

- 최대 길이가 되는, 오름차순으로 정렬되는 숫자열 추출

- 추출하는 순서는 유지되어야 한다.

  i.g., `[10, 4]` 가 있을 때, `[4, 10]`으로 추출할 수 없다.

예를 들어 설명을 이어보겠습니다.

- 랜덤한 숫자 배열: `[1, 8, 9,  4. 10, 5]`
- 가장 긴 오름차순 숫자열: `[1, 8, 9, 10]`

예시의 경우 길이가 짧은 배열이므로 쉽게 경우의 수를 고려하여 문제를 풀 수 있습니다. 하지만 긴 배열의 경우 굉장히 많은 연산이 필요합니다.

<br>

### Dynamic Programming

동적 계획법을 위해 추가적인 배열 하나를 생성합니다. 추가된 배열에는 연결 가능한 최대 길이 값을 부여합니다.

- 랜덤한 숫자 배열: **`[1, 8, 9,  4, 10, 5]`**
- **DP 배열: `[]`**

이제부터 인덱스 0부터 앞의 인덱스와 연결시켜 보겠습니다.

1. 인덱스 `0`(값 = `1`)

   - **DP 배열: `[1]`**

2. 인덱스 `1`(값 = `8`)

   1. `8` 시작, 길이 = 1
   2. `1` 연결, **길이 = 2**

   최대 길이는 1과 연결한 2입니다.

   - **DP 배열: `[1, 2]`**

3. 인덱스 `2`(값 = `9`)

   1. `9` 시작, 길이 = 1
   2. `1` 연결, 길이 = 2
   3. `8` 연결, **길이 = 3**

   - **DP 배열: `[1, 2, 3]`**

4. 인덱스 `3`(값 = `4`)

   1. `4` 시작, 길이 = 1
   2. `1` 연결, **길이 = 2**
   3. `8` 연결 불가
   4. `9` 연결 불가

   - **DP 배열: `[1, 2, 3, 2]`**

5. 인덱스 `4`(값 = `10`)

   1. `10` 시작, 길이 = 1
   2. `1` 연결, 길이 = 2
   3. `8` 연결, 길이 = 3
   4. `9` 연결, **길이 = 4**
   5. `4` 연결, 길이 = 3

   - **DP 배열: `[1, 2, ,3, 2, 4]`**

6. 인덱스 `5`(값 = `5`)

   1. `5` 시작, 길이 = 1
   2. `1` 연결, 길이 = 2
   3. `8` 연결 불가
   4. `9` 연결 불가
   5. `4` 연결, **길이 = 3**

   - **DP 배열: `[1, 2, 3, 2, 4, 3]`**

이렇든 앞의 모든 연결 가능한 숫자와 연결하는데, 그 중 최대값만을 배열에 추가해 나아갑니다. 원본 배열에서 연결할 수 있는 가장 긴 길이의 배열은 `10`를 마지막으로 하는 배열입니다.

**DP[x]: x 번째 수를 마지막 원소로 가지는 LIS의 길이**

<br>

### Code 1

2중 for문 사용하기

```c++
for (int i = 0; i < n; i++) {
    if (dp[i] == 0)dp[i] = 1;
    for (int j = 0; j < i; j++) {
        if (arr[i] > arr[j]) {
            if (dp[i] < dp[j] + 1) {
                dp[i] = dp[j] + 1;
            }
        }
    }
}
```

<br>

### Code 2

위의 코드는 O(`n^2`)의 시간 복잡도를 가지기 때문에, 다음과 같은 O(`nlogn`) 식으로 사용 가능

```java
vt.push_back(-INF);
for (int i = 0; i < n; i++) {
    scanf("%d", &x);
    if (vt.back() < x) {
        vt.push_back(x);
           ans++;
    }
    else {
        auto it = lower_bound(vt.begin(), vt.end(), x);
        *it = x;
    }
}
```

*위에 명시된 참고 자료 사이트에 자세한 설명이 있습니다.*



