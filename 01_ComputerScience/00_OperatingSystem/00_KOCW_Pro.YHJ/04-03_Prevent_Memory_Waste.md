# 4-3. 메모리 낭비 방지

메모리의 낭비를 방지할 수 있는 방법으로 세 가지가 있습니다.

1. 동적 적재, Dynamic Loading
2. 동적 연결, Dynamic Linking
3. Swapping

<br>

<br>

## 4-3-1. 동적 적재, Dynamic Loading

동적 적재는 프로그램 실행에 **반드시 필요한 Routine 및 Data 만을 적재**하는 방법입니다.

우리가 제작한 프로그램에는 실행하는데 있어서 필수적이지 않은 루틴 및 데이터도 존재합니다. 필수적이지 않은 루틴의 예로는 예외 처리가 있으며, 데이터의 경우 의미 없이 만들어진 배열이 있을 수 있습니다. 하지만 당장 필요하지 않다 해서 영원히 필요하지 않은건 아니므로, **필요할 경우 그 때 해당 부분을 메모리에 로드**합니다.

동적 적재의 반대 용어로는 **정적 적재(Static Loading)**이 있으며, 정적 적재는 필요 여부와 상관 없이 모든 내용을 로드합니다.

<br>

<br>

## 4-3-2. 동적 연결, Dynamic Linking

여러 프로그램에 공통적으로 사용되는 공통 라이브러리 루틴(Common Library Routine)을 메모리에 중복으로 올리는 것은 낭비입니다. 원래 실행 파일을 제작하기 이전에 필요한 라이브러리를 링크하지만, 공통되는 라이브러리 루틴은 오직 하나만 메모리에 로드한 채 나머지는 존재하는 루틴에 링크하여 사용합니다.

공통 라이브러리 루틴의 예로 printf(), Network Library, Sound Library 등이 있습니다. 동적 연결의 반대 용어는 **정적 연결(Static Linking)**입니다.

<br>

### 운영체제 별 용어

 운영체제 별로 다른 용어를 사용하기도 합니다.

- Linux - 공유 라이브러리, Shared Library
  - 확장자: `.so`
  - Shared Object
- Windows - 동적 연결 라이브러리, Dynamic Linking Library
  - 확장자: `.dll`

<br>

<br>

## 4-3-3. 스와핑, Swapping

메모리에 적재되어 있으나, **현재 사용되지 않고 있는 프로세스 이미지**를 보조 기억장치의 Backing Store(Swap Device)로 몰아냅니다. 몰아내는 것은 **Swap-out**이라고 하며, 다시 메모리에 적재시키는 것을 **Swap-in**이라고 합니다.

물론 MMU의 Relocation Register의 사용으로 swap 전후 주소 차이는 작업에 지장을 주지 않습니다만, **프로세스 크기가 크면 swap 작업의 오버헤드가 크게 발생**합니다.

