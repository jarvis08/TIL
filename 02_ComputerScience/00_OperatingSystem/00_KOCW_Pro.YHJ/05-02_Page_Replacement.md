

# 5-2. 페이지 교체, Page Replacement

아무리 필요한 페이지만을 메인 메모리에 로드하더라도, 언젠가는 메모리가 가득 차게 됩니다. 메모리가 가득 찬 상황이며, 추가적인 페이지를 메모리로 로드하고자 한다면, 로드 되어 있는 페이지를 backing store로 보내버린 후, 새로 사용할 페이지를 만들어 낸 빈 메모리 공간에 로드해야 합니다.

여기서 backing store로 페이지를 보내버리는 작업을 **Page-out**이라고 하며, 로드해 오는 작업을 **Page-in**이라고 합니다. 그리고 backing store로 보내지는 페이지를 **Victim Page**라고 부릅니다.

<br>

## 5-2-1. Victim Page

CPU는 어떤 페이지를 backing store로 보내야 효율적으로 작업할 수 있을 지 결정해야 합니다. 여기서 중요한 것은 최대한 **수정되지 않은 페이지를 Victim Page로 선정하는 것**입니다.

만약 메모리로 로드하기 이전과 비교했을 때 아무런 수정이 이루어지지 않은 파일을 backing store로 page-out하게 되면, backing store 내부에서 writing 할 일이 없습니다. 우리가 생각해야 할 것은 **I/O의 작업 처리 속도는 CPU의 속도 보다 매우 느리다**는 것입니다. 만약 수정이 이루어진 페이지라면, 해당 페이지의 수정 내용을 I/O 내부적으로 적용하는 작업이 필요하기 때문에 수정되지 않은 페이지를 page-out 하는 것이 효율적입니다.

<br>

### Modified Bit

페이지가 수정됐는지, 수정되지 않았는지 판단하는 작업은 또 다시 MMU가 수행해 줍니다. 5-1-1의 Valid Bit과 같이 **Modified Bit**을 설정하여 수정 여부를 표시합니다.

Modified bit은 과거에는 **Dirty Bit**이라고 불렸습니다.

<br>

<br>

## 5-2-2. 페이지 교체 알고리즘, Page Replacement Algorithms

여러 페이지들 중 어떤 페이지를 Victim Page로 설정하는가에 대한 방법들입니다. 페이지 교체 알고리즘들을 알아보기에 앞서, 각 알고리즘들이 사용하는 페이지 참조 열(Page Reference String)에 대해 알아보겠습니다.

<br>

### 페이지 참조 열, Page Reference String

MMU는 바이트로 표현되는 논리 주소로 부터 필요한 페이지가 무엇인지 알아내야 하며, 그 과정은 다음과 같습니다.

`논리 주소 -> 페이지 번호 -> 페이지 참조 열`

페이지 사이즈가 100 byte이며, CPU가 요구하는 주소들이 다음과 같다고 해 봅시다.

```
100, 101, 102, 432, 612, 103, 104, 611, 612
```

페이지 사이즈가 100이므로, 주소들의 페이지 번호는 다음과 같습니다.

```
1, 1, 1, 4, 6, 1, 1, 6, 6
```

우리는 여기서 참조해야 하는 페이지의 순서 열이 다음과 같음을 알 수 있습니다.

```
1, 4, 6, 1, 6
```

<br>

### 페이지 교체 알고리즘의 종류

1. FIFO, First-In First-Out
2. OPT, Optimal
3. LRU, Least-Recently-Used

<br>

### 1. FIFO, First-In First-Out







