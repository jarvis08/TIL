# 4-6. 세그멘테이션, Segmentation

## 4-6-1. 세그멘테이션이란?

**Paging**은 프로세스 내부의 **논리적 내용과는 무관하게, 일정한 고정된 크기**로 프로세스 이미지를 분할합니다. 그리고 페이지 테이블을 거쳐 메인 메모리에 접근하므로, 보호 기능과 공유 기능이 있음을 알 수 있습니다.

그런데 무관된 분할로 인하여 데이터 접근이 곤란해질 수 있습니다. 프로세스는 Code, Data, Stack의 형태로 메인 메모리에 로드됩니다. Code 부분을 분할하던 중, **페이지의 공간이 남아** Data를 일부 포함시키는 상황이 발생할 수 있습니다. 만약 Code 부분에 대해서는 `r` 권한을 갖고 있으며, Data에 대해서는 `w` 권한만을 가지고 있다면 이는 어떻게 해야 할까요?

이러한 문제를 해결해줄 수 있는 방법은 **세그멘테이션(Segmentation)**입니다. 세그멘테이션은 **프로세스를 논리적 내용(=세그멘트)으로 분할하여 메모리에 배치**합니다. 따라서 세그먼트들 끼리의 크기는 일반적으로 같지 않습니다.

페이징과 마찬가지로 **보호(Protection)**와 **공유(Sharing)** 효과가 있으며, 심지어 그 성능이 더 우수합니다. 위에서는 보호 효과에 대해 왜 세그멘테이션이 더 우수한가에 대해 설명드렸으니, 공유 효과에 대해 생각해 보겠습니다. 공유란 프로세스 별로 일정 부분을 공유하여 메모리 낭비를 방지하는 효과입니다. 그런데 **페이지를 공유할 경우, 의도하지 않은 프로세스의 부분들이 공유**될 수 있습니다. 하지만 논리적 내용으로 구분된 세그멘테이션의 경우 정확하게 원하는 내용만을 공유할 수 있습니다.

<br>

### 세그먼트 테이블, Segment Table

세그먼트 테이블과 페이지 테이블의 역할들 중 공통점은 다음과 같습니다.

- MMU 내의 **재배치 레지스터(Relocation Register)** 값을 통해 주소를 변경한다.

- CPU는 프로세스가 연속된 메모리 공간에 위치한다고 착각하며,

  그러한 형태와 동일하게 주소를 사용할 수 있다.

차이점은 다음과 같습니다.

- 페이지 테이블
  - Relocation Register에 메모리 번호(**프레임 번호**)를 보유하고 있다.
- 세그먼트 테이블
  - 메모리의 **Base Address**와 **Limit Address**를 보유하고 있다.

이러한 차이가 발생하는 이유는 세그멘테이션은 프레임(Frame)을 사용하지 않기 때문입니다. 프레임은 페이지와 같은 사이즈로 메인 메모리 공간을 분할하여 끼워 맞추기 위해 사용됩니다.

하지만 세그멘테이션의 경우 프로세스의 구성 별로, 세그먼트 별로 그 크기가 다르기 때문에 미리 예측된 공간인 프레임에 할당할 수 없습니다. 따라서 지정된 번호가 아니라, 직접 시작 주소와 종료 지점을 Relocation Register에 등록해 두어야 합니다.

<br>

<br>

## 4-6-2. 외부 단편화, External Fragmentation

### 현재 사용되는 방법

그렇다면 현재 우리가 주로 사용하는 운영체제들은 어떤 방법을 사용하는지 알아보겠습니다.

- Paging
  - Windws
  - Linux
- Segmentation
  - OS/2

분명 Segmentation이 더 우수한 효과가 있다고 공부했는데 왜 사용되지 않는 걸까요? 그 이유는 세그멘테이션에는 치명적인 단점이 있습니다.

<br>

### 세그멘테이션의 단점

세그멘테이션은 일부에서는 페이징보다 우수한 기능을 수행하지만, 페이징에는 없는 치명적인 단점이 있습니다. 페이징과 세그멘테이션을 사용하는 1차적인 목표는 **메인 메모리 낭비 제거**입니다. 하지만 논리적인 내용을 토대로 공간을 분할하다 보니, 세그멘트 별 크기가 가변적입니다. 따라서 연속 할당을 했을 때와 같은 문제인 **외부 단편화(External Fragmentation)**가 발생하며, First-fit/Best-fit/Worst-fit/Compaction과 같은 방안을 다시 고려해야 합니다.

<br>

### 해결 방안, Paged Segmentation

세그멘테이션의 보호 기능과 공유 기능을 살리면서, 페이징의 외부 단편화 문제 해결을 하고자 고안된 것이 바로 '**세그멘트들을 페이징**'하는 방법입니다. Paged Segmenatation은 파워와 속도를 Trade-off한 것으로, Translation 과정은 다음과 같습니다.

`CPU` - `Segment Table` - `Page Table` - `Main Memory`

거쳐야 할 테이블의 수가 늘어 속도는 조금 줄었지만, 두 가지 방법의 장점을 모두 살릴 수 있는 방안입니다.

<br>

### 현대의 OS들은 어떻게 사용하나?

[stackoverflow](https://stackoverflow.com/questions/24358105/do-modern-oss-use-paging-and-segmentation)

Paging만을 사용하며, Segmentation은 잘 사용하지 않는다.

