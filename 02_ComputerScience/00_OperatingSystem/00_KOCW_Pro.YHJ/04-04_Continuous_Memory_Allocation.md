# 4-4. 연속 메모리 할당, Continuous Memory Allocation

연속 메모리 할당은 프로세스를 연속된 메모리 공간에 할당하는 방식입니다. 즉, 프로세스 하나의 모든 내용은 그것들끼리 연속되는 메모리 공간에 함께 적재되어 있습니다.

<br>

<br>

## 4-4-1. 연속 메모리 할당 방식

연속 메모리 할당에는 세 가지 방법이 있습니다.

1. 최초 적합, First-fit
2. 최적 적합, Best-fit
3. 최악 적합, Worst-fit

<br>

### 최초 적합, First-fit

메모리의 위/아래에서 시작하여 프로세스가 적재될 수 있는, 최초로 발견된 공간에 적재합니다.

<br>

### 최적 적합, Best-fit

공간 크기가 최대한 비슷한 곳에 적재합니다.

<br>

### 최악 적합, Worst-fit

공간 크기 차이가 가장 큰 곳에 적재합니다.

<br>

### 할당 방식의 성능 비교

- 가장 빠른 할당 속도: First-fit

- 메모리 공간 이용률: First-fit, Best-fit

  공간 이용률은 두 방식이 대부분 유사합니다.

<br>

<br>

## 4-4-2. 연속 메모리 할당의 문제점

우리가 보통 사용하는 다중 프로그래밍 환경을 고려해 보겠습니다. 부팅 직후의 메인 메모리에는 운영체제를 제외한 나머지 공간에는 아무 프로세스도 적재되어 있지 않습니다(big single hole).

하지만 컴퓨터를 사용하면서, 여러 프로세스들을 생성하고 종료하기를 반복하다 보면 메모리 안에는 빈 공간과 사용중인 공간이 흩어져서 존재(scattered holes)하게 됩니다. 이 때, hole 들이 불연속하게 흩어져 있는 현상을 **메모리 단편화(Memory Fragmentation)**라고 부르며, 정확히는 **외부 단편화(External Fragmentation)**라고 합니다. 외부 단편화가 발생하면, 사용되지 않는 메모리 공간의 크기가 충분하더라도 프로세스를 할당할 수 없는 상황이 발생합니다.

외부 단편화로 인해 메모리 공간의 1/3 수준을 활용하지 못하게 됩니다.

<br>

### 해결 방법, Compaction

Scattered Holes를 한 곳으로 모으는 작업입니다. 하지만 실행 중인 프로세스들을 다른 공간으로 밀어내는 작업에는 큰 오버헤드가 발생하며, 최적 알고리즘이 존재하지 않기 때문에 **해결 방법이라고 표현할 수 없습니다.**

보다 해결 다운 해결을 위해 **페이징(Paging)** 기법을 사용합니다.

