# 부분 집합(Subset) 탐색

---

멱집합(Powerset) : 모든 부분집합의 경우의 수를 포함하는 집합

- 유한 개의 정수로 이루어진 집합이 존재할 때,

  부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는가?

1. 완전 검색 기법

      집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산

        - 파스칼의 삼각형 응용 (재귀 함수 이용 가능)

          {1, 2, 3} 집합이 있으며, 각 원소의 등장 여부를 1과 0으로 표시

          - 111, 110, 101, 100, 011, 010, 001, 000

            = {1, 2, 3}, {1, 2}, {1, 3}, {1}, {2, 3}, {2}, {3}, {none}

          ```python
          a = [0, 0, 0]
          for i in rnage(2):
              a[0] = i
               for j in range(2):
                      a[1] = j
                      for k in range(2):
                          a[2] = k
          				print(a)
          ```

      - 집합의 원소 개수와 중첩된 for문 개수가 비례하며,

        경우의 수는 `2 ** (원소개수)`

2. 비트(Binary Digit) 연산 이용

      - 비트 연산 기초

        0과 1로만 구성

        - `&`, AND

          `1, True` = (1, 1)

        - `|`, OR

          `1, True` = (1, 1), (1, 0), (0, 1)

        - `^`, exclusive, XOR

          `True` = (1, 0), (0, 1)

        - `<<`

          `x = 1` 일 때 `x << n` = `2 ** n`

          ```
          x = 1 일 때
          x의 2진법 = 001
          x << 1 :: 010 = 2
          x << 2 :: 100 = 4
          ```

        - `>>`

          ```
          x = 12 일 때,
          x는 2진법으로 1100
          x >> 1 :: 0110 = 6
          x >> 2 :: 0011 = 3 
          ```

        - `i & (1 << j)`

          `i` : 어떤 수

          `j` : `j` 번째 비트

          - `1 << j`는 j 비트를 제외하고는 모두 masking

          - `&`로 인해 `i`의 `j`번째 비트가 1이면 `True`, 0이면 `False`

            i.e., i의 j번째 비트가 무엇인지 알고 싶을 때 사용

      - 1(True), 0(False) 두 값만 필요하므로 Binary Counting을 이용하여 풀 수 있다.

        ```
        111 = 7
        110 = 6
        101 = 5
        100 = 4
        011 = 3
        010 = 2
        001 = 1
        000 = 0
        ```

        ```python
        # 부분집합 출력해보기
        arr = [3, 6, 7, 1, 5, 4]
        # 원소 개수
        n = len(arr)
        
        # 1 << n : 부분집합의 개수 i
        for i in range(1 << n):
            # 원소의 개수(j = 0 ~ 5)만큼 비트를 비교
            for j in range(n):
                # i의 j번째 비트가 1이면 j번째 원소를 출력
                if i & (1 << j):
                    print(arr[j], end=', ')
            print()
        ```

        - `i == 47` 일 때,

          47 = 32 + 8 + 4  + 2 + 1 = 101111

          - `j == 0`

            `101111`와 `000001`을 `&` = 1

            `101111`와 `000010`을 `&` = 1

            `101111`와 `000100`을 `&` = 1

            `101111`와 `001000`을 `&` = 1

            `101111`와 `010000`을 `&` = 0

            `101111`와 `100000`을 `&` = 1

          - i.e., 48번째(`i=47`) subset은 `i & (1 << j) = 1`을 만족하는 `arr[j]`들의 집합인 {3, 6, 7, 1, 4}

3. Exercise. 정수 집합 중, 부분 집합의 합이 0이되는 부분 집합 구하기

      ```python
      origin_set = [1, 2, -1, -3, 4, -2, 5]
      n = len(origin_set)
      subsets = []
      for i in range(1 << n):
          subset = []
          for j in range(n):
              if i & (1 << j):
                  subset += [origin_set[j]]
          subsets += [subset]
      
      sum_zero = []
      for sub in subsets:
          sum_sub = 0
          if not len(sub):
              # 공집합 제거
              continue
          for element in sub:
              sum_sub += element
          if not sum_sub:
              sum_zero += [sub]
      print(sum_zero)
      ```
