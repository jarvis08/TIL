# Overall of Searching Algorithms

- O(`n`), 선형 시간, Linear Time 
  - 순차 탐색
- O(`nlogn`), 로그 선형 시간, Log-Linear time
- O(`n^2`), 제곱 시간, Quadratic time 
  - 최소 신장 트리- 프림 Prim
  - 최소 신장 트리- 크루스칼 Kruscal
  - 다익스트라, 두 정점 간의 최단 거리 구하기
- O(`n^3`), 세제곱 시간, Cubic time 
  - 플로이드 - 워셜, 모든 정점과 연결하는 최단거리 구하기에 사용되며, DP를 활용
- O(`2^n`), 지수 시간, Exponential time 
  - 부분집합 구하기, 배낭문제, 순열, TSP
  - 근사 알고리즘, 인공지능으로의 해결이 요구됨

<br>

<br>

## 순차 탐색, Linear Search

찾고자 하는 레코드가 나타날 때까지 차례로 비교하면서 순차적으로 검색을 수행한다.

<br><br>

## 이진 탐색, Binary Search

- 중앙값은 루트에 있으며, 파일의 중앙에서부터 탐색한다.
- 정렬된 상태의 배열을 정 가운데 index와 찾고자 하는 값을 비교하여 값을 찾아내는 방식
- 이진 탐색을 위한 트리는 루트의 중앙값을 시작으로 왼쪽에는 부모노드 보다 작은 수가 저장되고, 오른쪽은 큰 수가 저장됨
- 찾고자 하는 수가 비교하는 노드보다 작으면 비교 노드의 왼쪽 자식노드로 가서 비교하고 크면 오른쪽 자식노드로 가서 비교하며, 이러한 과정을 반복하며 찾아나감
- 하지만, 정렬되지 않는 배열에 적용할 수 없다는 단점을 가진다.

<br><br>

## 피보나치 탐색, Fibonacci Search

나눗셈을 사용하지 않고 덧셈과 뺄셈만 사용

나눗셈이 덧셈이나 뺄셈보다 더 많은 시간 소요

- 평균 효율이 이진탐색 보다 좋음

<br><br>

## AVL 트리

- 원소의 삽입과 삭제 연산 시간도 짧으면서 검색 시간이 을 갖는 2-원 탐색 트리
- 왼쪽 서브트리와 오른쪽 서브트리의 높이의 차가 1이하인 2-원 탐색 트리
- 노드의 균형 인수가 ۫이하이면 그 노드는 AVL 성질을 만족하고 ۬이상이면 AVL 성질을 만족하지 못함

<br><br>

## 해싱, Hashing

- 특정 Key를 Hash Function에 넣어 얻은 값을 index로 사용하여 해당 index에 데이터를 저장하는 방식
- 다른 Key값이 같은 index를 내놓는 Collision이 발생할 수 있다. Collision의 해결방법이 필요하다.

### **1-5-1. Open-Address Hashing**

- Linear Probing 
  - 특정 Hash Function을 통해 얻어낸 index를 *hash(key)* 라고 한다.
  - 만약 *data[hash(key)]* 가 비어있으면 저장하고 끝낸다.
  - 비어있지 않으면, *data[hash(key)+1]* 를 확인하고 비어있으면 저장후 종료, 비어있지 않으면 index를 하나씩 늘려가면서 확인한다.
- Doublie Hasing 
  - Linear Probing의 경우 Clustering Problem으로 인해 Insertion 작업의 시간이 오래 걸릴 수 있다.
  - *Hash Function 1*과 *Hash Function 2*를 정의한다.
  - *Hash Function 1*을 통해 얻어낸 index가 비어있지 않으면 *Hash Function 2*를 통해 얻은 값을 index에 더한다.

### **1-5-2. Chanined Hasing**

- Array가 하나 이상의 Entry를 가질 수 있는 Hashing 방법이다.
- Collision이 발생하면 해당 index에 새로운 Entry를 추가한다.

### **1-5-3. Table**

- Table은 record에 대해 Insertin, Deleting, Locating을 수행하는 container이다.
- Single Key Field에 의해 결정된다.
- Hash와 Table의 개념이 합펴진 것이 HashTable이다.
- 키 값에 특별한 수식을 적용하여 원하는 자료가 저장되어 있는 주소를 직접 알아냄(직접주소를 이용하여 빠르게 탐색)
- 충돌 : 자료를 삽입할 때 두 개의 서로 다른 자료가 해싱 함수에 의해 똑같은 주소의 버킷으로 해싱되는 경우가 발생되는 현상

### **1-5-4. 해싱 함수**

해싱 테이블 내의 버킷 주소로 변환하며, 주소가 특정 주소에 편향되지 않도록 하고, 편향된 주소로 해싱된 자료들이 오버플로우를 발생시키지 않도록 하는 것이 중요하다.

- 해싱 함수의 종류 

  1. 제산 잔여 해싱 : 나머지 연산자(%)를 사용하여 키를 어떤 정해진 수로 나누고 나머지를 버킷 주소로 사용

     가장 큰 소수를 제수로 사용

  2. 중간 제곱 해싱 : 키 값을 제곱한 후에 그 결과의 중간에서 미리 정해진 자리의 숫자를 뽑아내어 버킷 주소로 사용

  3. 폴딩 해싱 : 키 값을 주소와 같은 자리수를 갖는 몇 개의 부분으로 나눈 다음, 그 부분들을 서로 더하여 주소를 만들어 내는 방법

     가. 이동 폴딩 방법 : 나누어진 부분의 값을 그대로 더하는 방법

     나. 경계 폴딩 방법 : 마치 종이를 접듯이 부분을 경계에서 겹친 다음

     만나는 수를 더하는 방법

  4. 숫자분석 해싱 : 저장할 자료를 미리 알고 있는 경우에 유용하게 활용

     키 값의 분포를 활용하여 적절하게 배치

### **1-5-5. 충돌 해결 방법**

- 개방 주소법

  선형 조사법 : 비어있는 버킷을 찾아 자료를 저장하는 방법

- 폐쇄 주소법

  체인법 : 각 버킷마다 개별적인 연결리스트 구조를 할당하는 방식