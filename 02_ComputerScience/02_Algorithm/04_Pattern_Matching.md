# Pattern Matching

> 고지식한 패턴 검색 알고리즘, Brute Force
>
> 카프-라빈 알고리즘
>
> KMP 알고리즘
>
> 보이어-무어 알고리즘

### 고지식한 패턴 검색 알고리즘, Brute Force

```python
def BruteForce(t, p):
    len_t = len(t)
    len_p = len(p)
    # t의 인덱스
    i = 0
    # p의 인덱스
    j = 0
    
    # 원본이 끝나거나 일치 지점을 찾을 때 까지
    while i < len_t and j < len_p:
        ## 패턴이 아닐 경우 위치를 돌려놓기
        # 만약 탐색 중 다르다고 판명된다면
        if t[i] != p[j]:
            # 탐색한 만큼 i 돌려놓기
            i = i - j
            # p를 처음(0)으로 돌려야 하는데, 이후에 +1 해줄 예정이므로 -1
            j = -1
        i += 1
        j += 1
    # j가 p 길이가 될 때까지 값이 같았다면
    if j == len_p:
        # 탐색하느라 증가한 i를 탐색한 만큼 낮추어 return
        return i - len_p
    else:
        # 통틀어서 발견하지 못했다면
        return -1
    
    
# 전체 텍스트
t = 'This is a book!'
# 찾을 패턴
p = 'is'
print(BruteForce(t, p))
```

- 최악의 경우 텍스트의 모든 위치에서 패턴을 비교

  시간 복잡도 = O(MN)

### KMP 알고리즘

- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는가를 미리 알고 있으므로,

  불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행

- 패턴을 전처리하여 배열 `next[M]`을 구하여 잘못된 시작을 최소화

  - `next[M]` : 불일치가 발생했을 경우 이동할 다음 위치

- 시간 복잡도 = O(M + N)

- 방법

  1. Preprocessing

     (접두어 기준/접미어 기준)을 나열 및 비교하여, 겹치는 부분의 길이가 최대인 것을 탐색

  2. (패턴길이 - 최대 길이)만큼을 shifting 하며 탐색

### 보이어-무어 알고리즘

- 패턴의 뒤에서부터 비교 시작

- 대부분의 상용 SW에서 채택하는 알고리즘

- 패턴 문자가 일치하지 않을 시, 패턴의 길이만큼을 shift

- 오른쪽 끝 문자가 불일치하고, 비교했던 본문의 문자가 패턴내에 존재할 경우

  패턴에서 일치하는 문자를 찾아서 둘의 위치를 맞춰서 비교

- 최악의 경우 example

  본문 = 'aaaaa...baa'

  패턴 = 'baa'

  a가 계속해서 있으므로  패턴을 모든 a에 맞춰서 비교

### 문자열 매칭 알고리즘 비교

- 찾고자 하는 문자열 패턴의 길이를 m, 총 문자열의 길이를 n이라 할 때

  - 고지식한 패턴 검색 알고리즘

    수행시간 = O(mn)

  - 카프-라빈 알고리즘

    수행시간 = O(n)

