# Intro

---


## APS, Algorithm Problem Solving 기본

- 백경원 강사님

  과제 제출 beeback@hanmail.net 당일 자정까지

  - Talk > Solving Club > Solving Club > 2기서울1반 > Problem Box > 1문제

  - Learn > Course > Programming Intermediate > 회차 별 4문제

    4문제의 경우 메일로 제출

    메일 제목 : 2기서울1반1월17일조동빈

    파일 제목 : 서울1반1월17일조동빈.zip

- Problem Solving

  - Type
  - 제어
    - 순차
    - 선택
    - 반복

<br>

<br>

## 알고리즘, Algorithm

- 정렬

- 검색

  정렬 상태에 따라 검색 속도가 판이

  - **해쉬, Hash**

  - **완전 검색, Exhaustive Search**

    **Brute-force** 혹은 **Generate-and-Test**라고도 불림

    모든 경우의 수를 테스트한 후 최종 해법 도출

    수행 속도가 느리지만, 해답 탐색 확률이 높다.

    - Coding Test의 경우 완전 검색으로의 접근 후,

      성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인

  - 조합론

    모든 case를 생성하는 방법론

    - 순열

      대표 문제 = TSP

      시간복잡도 O(n!)

      n!의 시간 복잡도를 가지는 완전 검색

    - 조합

    - 부분 집합

      대표 문제 = 배낭 문제

      O(2**n)

      지수승의 시간 복잡도를 가지는 완전 검색(NP 클래스 문제)

      - O(n**k) 시간복잡도를 가지는 완전 검색(P클래스 문제)

      n이 커지면 늙어 죽을때까지 결과 못보기 때문에 다른 방법을 시도(Tree 구조를 활용)

      - 근사 알고리즘
      - 인공지능

<br>

<br>

## Algorithm 설계 기법

- Greedy

  탐욕 알고리즘 설계 기법

  검증이 필수적이며, 쉽게 사용할 수 없다.

- 분할 정복

  중요하며, 제어문을 사용할 때 부분적으로 사용

- **Back Tracking**

  - 상태 공간 트리 문제를 DFS로 해결 할 때, Stack 혹은 재귀를 이용하여 구현
  - 혹은 BFS를 사용하여 우선 순위에 따라 Queue를 이용하여 해결

- DP, Dynamic Programming

  - 재귀적 DP

    때에 따라서는 재귀적 DP의 속도가 빠른 경우도 존재

    Back Tracking이 기본

  - 반복적 DP

<br>

### 알고리즘이란?

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

- 슈더코드

  Team마다 다르며, Google에서 만든 대표 문헌이 존재

- 순서도

  명령어를 기준으로 작성하며, 규모가 커질 수록 abstract한 단위로 표현

- 좋은 알고리즘

  1. **정확성**

  2. **작업량**

     논리적/물리적인 적은 연산

     - 검정 서버

       10초 제한, 10초안에 output이 나오는가

       검정 환경에 따라 시간 차이가 존재

     - 시간 복잡도

       명령어의 수에 따라 작업량을 계산

       e.g., Big O 표기법

  3. 메모리 사용량

  4. 단순성

     Maintenance 및 Team 단위의 작업에 중요

  5. 최적성

<br>

<br>

# Big O 표기법

- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시하며, 계수(Coefficient) 생략

  e.g., `O(3n+2) = O(n)`

  `O(2n^2 + 10n + 100) = O(2n^2)`

- 시간 복잡도 연산 수 오름차순
  1. `O(1)`
  2. `O(logn)`
  3. `O(n)`
  4. `O(nlogn)`
  5. `O(n^2)`
  6. `O(2^n)`
  7. `O(n!)`

<br>

### 예제

- Baby-gin 문제

  6장의 카드가 `run`+`triplet`으로 구성된 경우(추출 순서 무관)

  e.g., 667767, 054060

  - 0~9 사이의 숫자 카드에서 임의의 카드 6장 추출

    - `run` : 3장의 카드가 연속적인 번호
    - `triplet` : 3장의 카드가 동일한 번호

  - 완전 검색을 이용한 Baby-gin

    1. 모든 숫자 나열을 모두 조사(중복 포함)
    2. 전/후반부 3개 숫자씩 나눈 후 `run`, `triplet` 여부를 테스트

  - Greedy적 접근법

    `run` 혹은 `triplet` 중 한 가지를 고른 후,

    찾아지면 나머지 숫자에 대해 `triplet` 혹은 `run`인지 판단

<br>

<br>

## 탐욕, Greedy

- 탐욕 알고리즘 설계 기법

  최적해를 구하는 데에 사용되는 근시안적인 방법

  여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라 생각되는 것을 선택해 나아가는 방식

- Local Optimization != Global Optimization

  따라서 머릿속에 떠오른 내용은 검증 방법이 필요

- 동작 과정

  1. 해 선택

     현재 상태에서 부분 문제의 최적해를 구한 후,

     이를 부분해 집합(Solution Set)에 추가

  2. 실행 가능성 검사

     새로운 부분해 집합이 실행 가능한지 확인

     문제의 제약 조건을 위반하지 않는지 검사

  3. 해 검사

     새로운 부분해 집합이 문제의 해가 되는지 확인

     아직 전체 문제의 해가 완성되지 않았다면, 1.의 해 선택부터 다시 시작

- Greedy의 위험성 예시

  - 거스름돈이 80원일 때 동전 개수 최소화, 동전의 단위 시스템은 {50원, 40원, 10원}

    - Greedy : 4개 (50원, 10원 * 3)
    - 최적해 : 2개 (40원 * 2)

  - Baby-gin

    [1, 1, 1, 2, 3, 4]가 뽑혔다고 했을 때,

    `triplet` 탐색 이후 `run`을 찾으면 baby-gin이지만

    역순으로 탐색하면 baby-gin이 아니다.

